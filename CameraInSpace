from mpl_toolkits import mplot3d
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import axes3d
import math
# get axis unit vector from dcm rows
# def get_vector_from_dcm(dcm, axis, o, label, color):
#     """
#     dcm: direction cosine matrix (3x3 numpy array)
#     axis: basis vector to extract (0 = x, 1 = y, 2 = z)
#     """
#     return Vector3D(dcm[axis, :][0], dcm[axis, :][1], dcm[axis, :][2], origin=o, text=label, color=color)
# Coordonnées de l'origine
world_origin = np.zeros(3)
# Vecteurs de la base du monde
dx, dy, dz = np.eye(3)
# Vecteur de translation
t = np. array([3, -4, 2])
p0 = [1, 0, 0]
p1 = [0, 1, 0]
p2 = [0, 0, 1]
# Matrice de rotation R


def Matrice_Rotation_2D(teta):
    return np.array([[math.cos(teta), -math.sin(teta)], [math.sin(teta), math.cos(teta)]])

# Matrice de rotation 3D autour de l'axe x


def Matrice_Rotation_3D_X(teta):
    return np.array([[1, 0, 0, 0], [0, math.cos(teta), -math.sin(teta), 0], [0, math.sin(teta), math.cos(teta), 0], [0, 0, 0, 1]])
# Matrice de rotation autour axe y


def Matrice_Rotation_3D_Y(teta):
    return np.array([[math.cos(teta), 0, math.sin(teta), 0], [0, 1, 0, 0], [-math.sin(teta), 0, math.cos(teta), 0], [0, 0, 0, 1]])
# Matrice de rotation autour axe z


def Matrice_Rotation_3D_Z(teta):
    return np.array([[math.cos(teta), -math.sin(teta), 0, 0], [math.sin(teta), math.cos(teta), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])
# Matrice de Translation


def matrice_translation_3D(Tx, Ty, Tz):
    return np.array([[1, 0, 0, Tx], [0, 1, 0, Ty], [0, 0, 1, Tz], [0, 0, 0, 1]])


origin = [0, 0, 0]
# Zip function iterator of tuples qui associe les éléments à la suite X devient (0,0,0)
# Concatène les tableaux possiblement
X, Y, Z = zip(origin, origin, origin)
print(X)
U, V, W = zip(p0, p1, p2)
print(U)

fig = plt.figure()
# Crée le plan de la figure en mode 3D
ax = fig.add_subplot(111, projection='3d')
# Need matplotlib
# Plot a 2D/3D field of arrow X,Y,Z defines the arrow location
# U,V,W defines the arrow direction [C] define the color
# Create a translation
U1, V1, W1 = zip(origin+t, origin+t, origin+t)
ax.quiver(X, Y, Z, U, V, W, color="red",
          arrow_length_ratio=0.01)
ax.quiver(U1, V1, W1, U, V, W, color="blue", arrow_length_ratio=0.01)
plt.show()
