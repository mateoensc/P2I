from mpl_toolkits import mplot3d
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import axes3d
import math
# get axis unit vector from dcm rows
# def get_vector_from_dcm(dcm, axis, o, label, color):
#     """
#     dcm: direction cosine matrix (3x3 numpy array)
#     axis: basis vector to extract (0 = x, 1 = y, 2 = z)
#     """
#     return Vector3D(dcm[axis, :][0], dcm[axis, :][1], dcm[axis, :][2], origin=o, text=label, color=color)
# Coordonnées de l'origine
world_origin = np.zeros(3)
# Vecteurs de la base du monde
dx, dy, dz = np.eye(3)
# Vecteur de translation
t = np. array([3, -4, 2])
p0 = [1, 0, 0]
p1 = [0, 1, 0]
p2 = [0, 0, 1]
# Matrice de rotation R


def Matrice_Rotation_2D(teta):
    return np.array([[math.cos(teta), -math.sin(teta)], [math.sin(teta), math.cos(teta)]])

# Matrice de rotation 3D autour de l'axe x


def Matrice_Rotation_3D_X(teta):
    return np.array([[1, 0, 0, 0], [0, math.cos(teta), -math.sin(teta), 0], [0, math.sin(teta), math.cos(teta), 0], [0, 0, 0, 1]])
# Matrice de rotation autour axe y


def matrice_rotation_3D_Y(teta):
    teta = math.radians(teta)
    return np.array([[math.cos(teta), 0, math.sin(teta), 0], [0, 1, 0, 0], [-math.sin(teta), 0, math.cos(teta), 0], [0, 0, 0, 1]])
# Matrice de rotation autour axe z


def matrice_rotation_3D_Z(teta):
    return np.array([[math.cos(teta), -math.sin(teta), 0, 0], [math.sin(teta), math.cos(teta), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])
# Matrice de Translation


def matrice_translation_3D(Tx, Ty, Tz):
    return np.array([[1, 0, 0, Tx], [0, 1, 0, Ty], [0, 0, 1, Tz], [0, 0, 0, 1]])


origine = [0, 0, 0]
# Zip function iterator of tuples qui associe les éléments à la suite X devient (0,0,0)
# Concatène les tableaux possiblement
X, Y, Z = zip(origine, origine, origine)
print(X)
U, V, W = zip(p0, p1, p2)
print(U)
Pmonde = np.array([-3, 0, 2, 1])
# Teta in degree
Ry = matrice_rotation_3D_Y(20)
print("Ry :",Ry)
T = matrice_translation_3D(5, 0, 21)
print("T : ",T)
# Coordonnées de l'origine référentiel monde
monde = np.array([5, 0, 21,1])
print(monde.shape)
vecteurmondex = [1, 0, 0,0]
vecteurmondey = [0, 1, 0,0]
vecteurmondez = [0, 0, 1,0]
monderotationx = np.dot(Ry,vecteurmondex)
monderotationy = np.dot(Ry,vecteurmondey)
monderotationz = np.dot(Ry,vecteurmondez)
# Test normalisation du vecteur 
monderotationx = monderotationx/np.linalg.norm(monderotationx)
monderotationy =monderotationy/np.linalg.norm(monderotationy)
monderotationz = monderotationz/np.linalg.norm(monderotationz)
print("Vecteur rotation ",monderotationx,"y",monderotationy,"z",monderotationz)
# Pc = T*R*Pm
intermediate = np.dot(Ry,Pmonde)
Pcamera = np.dot(T,intermediate)
print("Pc :",Pcamera)
#fig = plt.figure()
# Crée le plan de la figure en mode 3D
#ax = fig.add_subplot(111, projection='3d')
# Need matplotlib
# Plot a 2D/3D field of arrow X,Y,Z defines the arrow location
# U,V,W defines the arrow direction [C] define the color
# Create a translation
# U1, V1, W1 = zip(origine+t, origine+t, origine+t)
# ax.quiver(X, Y, Z, U, V, W, color="red",
#           arrow_length_ratio=0.01)
# ax.quiver(U1, V1, W1, U, V, W, color="blue", arrow_length_ratio=0.01)

# define axis and figure
fig = plt.figure(figsize=(6, 4))
ax = fig.add_subplot(111,projection='3d')

# set limit
ax.set(xlim=(-5, 5), ylim=(-5, 5), zlim=(0, 20))


X, Y, Z = zip(monde[0:3], monde[0:3], monde[0:3])
U, V, W = zip(monderotationx[0:3],monderotationy[0:3], monderotationz[0:3])
#print("Monde rotation : ",monderotation[0][0:3])
U2, V2, W2 = zip(p0, p1, p2)
U1, V1, W1 = zip(origine, origine, origine)
# Référentiel du monde
ax.quiver(X, Y, Z, U, V, W, color="red",
          arrow_length_ratio=0.01 )
# Référentiel de la caméra
ax.quiver(U1, V1, W1, U2, V2, W2, color="blue", arrow_length_ratio=0.01)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')

plt.show()
